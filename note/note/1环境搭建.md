# 环境搭建

## 一、项目结构搭建

​	模块关系

​		parent模块仅仅用来确定各个Maven依赖的版本

​		webui、component、entity模块继承自parent模块

​		util、reverse模块属于独立工程，不参与继承与聚合

​		且webui依赖于component，component依赖于entity、util。

![依赖结构](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210710213712.png) 

​	各个工程的打包方式：

```xml
<!--parent-->
    <groupId>org.example</groupId>
    <artifactId>crowdfunding01-admin-parent</artifactId>
    <version>1.0-SNAPSHOT</version>
<packaging>pom</packaging>

<!--webui-->
	<packaging>war</packaging>
<!--其他的模块都是默认打包方式（jar）-->
```

​	IDEA中创建多模块工程：

​		先创建一个Empty Project（空工程），创建完成后一个个添加各个Maven模块

​		由于webui模块，需要打成war包，因此需要有web工程的目录结构，可以通过在Modules中添		加，产生对应的结构：

![产生web.xml](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210710213725.png)

​		模块创建时应该选择好父模块

## 二、数据库构建与逆向

### 	1、建表：

```sql
CREATE DATABASE project_rowd CHARACTER SET utf8;

USE project_rowd;
drop table if exists t_admin;				# 如果存在t_admin则删除存在的表
    CREATE TABLE t_admin (
    id INT NOT NULL auto_increment,			# 主键
    login_acct VARCHAR ( 255 ) NOT NULL,	# 登录账号
    user_pswd CHAR ( 32 ) NOT NULL,			# 登录密码
    user_name VARCHAR ( 255 ) NOT NULL,		# 昵称
    email VARCHAR ( 255 ) NOT NULL,			# 邮件地址
    create_time CHAR ( 19 ),				# 创建时间
    PRIMARY KEY ( id ) 						# 设置主键
);
```

​	进行基于Maven的逆向工程（根据已存在的表，在项目中逆向生成对应的实体类、Mapper文件、Mapper接口）

### 	2、在reverse模块中进行逆向：

#### 		1）、pom.xml中导入依赖

```xml
    <!--控制 maven 在构建过程中的相关配置-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.mybatis.generator</groupId>
                <artifactId>mybatis-generator-maven-plugin</artifactId>
                <version>1.4.0</version>
                <dependencies>
                    <!--逆向工程核心依赖-->
                    <dependency>
                        <groupId>org.mybatis.generator</groupId>
                        <artifactId>mybatis-generator-core</artifactId>
                        <version>1.4.0</version>
                    </dependency>
                    <!--数据库连接池-->
                    <dependency>
                        <groupId>com.mchange</groupId>
                        <artifactId>c3p0</artifactId>
                        <version>0.9.5.5</version>
                    </dependency>
                    <!--MySQL 驱动-->
                    <dependency>
                        <groupId>mysql</groupId>
                        <artifactId>mysql-connector-java</artifactId>
                        <version>8.0.23</version>
                    </dependency>
                </dependencies>
                <configuration>
                    <overwrite>true</overwrite>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

#### 			2）、编写generatorConfig.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="atguiguTables" targetRuntime="MyBatis3">
        <commentGenerator>
            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->
            <property name="suppressAllComments" value="true" />
        </commentGenerator>

        <!-- 数据库链接URL、用户名、密码 -->
        <jdbcConnection
                driverClass="com.mysql.cj.jdbc.Driver"
                connectionURL="jdbc:mysql://localhost:3306/project_rowd?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8"
                userId="root"
                password="root">
        </jdbcConnection>

        <!--
        默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer
            true，把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal
        -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>

        <!--
        生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，
        也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下
        -->
        <!--<javaModelGenerator targetPackage="com.joey.mybaties.test.pojo" targetProject="MAVEN">-->
        <javaModelGenerator targetPackage="com.mao.crowd.entity" targetProject=".\src\main\java">
            <!--是否让schema作为包的后缀-->
            <property name="enableSubPackages" value="false"/>
            <!-- 从数据库返回的值被清理前后的空格  -->
            <property name="trimStrings" value="true" />
        </javaModelGenerator>

        <!--对应的mapper.xml文件  -->
        <sqlMapGenerator targetPackage="com.mao.crowd.mapper" targetProject=".\src\main\java">
            <!--是否让schema作为包的后缀-->
            <property name="enableSubPackages" value="false"/>
        </sqlMapGenerator>

        <!-- 对应的Mapper接口类文件 -->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.mao.crowd.mapper" targetProject=".\src\main\java">
            <!--是否让schema作为包的后缀-->
            <property name="enableSubPackages" value="false"/>
        </javaClientGenerator>

        <!-- 数据库表名与需要的实体类对应映射的指定 -->
        <table tableName="t_admin" domainObjectName="Admin"/>
    </context>
</generatorConfiguration>
```

​			在IDEA中进行逆向工程的方法：

![逆向工程](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210710225411.png) 

运行完后，应当对产生的所有文件各归各位（Mapper接口放入component的mapper包下；实体类放入entity模块的entity包；xxxMapper.xml放入webui的resources文件夹下**（xml放在web模块下方便寻找）**）



## 三、通过父工程管理依赖版本

在父工程通过**dependencyManagement**标签管理依赖版本，但是在子工程正式通过**dependencies**标签导入依赖前，这些依赖并不会生效

```xml
    <properties>
        <!--声明属性，对 Spring 的版本进行统一管理-->
        <mao.spring.version>5.3.6</mao.spring.version>
        <!--声明属性，对 SpringSecurity的版本进行统一管理-->
        <mao.spring.security.version>5.5.0</mao.spring.security.version>
    </properties>

    <dependencies>
        <!-- Spring 依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-orm</artifactId>
            <version>${mao.spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${mao.spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>${mao.spring.version}</version>
        </dependency>

        <!-- Spring AOP -->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.6</version>
        </dependency>
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.3.0</version>
        </dependency>
        <!-- 数据库依赖 -->
        <!-- MySQL -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>
        <!-- 数据源 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.5</version>
        </dependency>
        <!-- MyBatis -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.5</version>
        </dependency>
        <!-- MyBatis 与 Spring 整合 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.6</version>
        </dependency>
        <!-- MyBatis 分页插件 -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>5.2.0</version>
        </dependency>

        <!-- 日志相关依赖 -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.30</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>
        <!-- 其他日志框架的中间转换包 -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>jcl-over-slf4j</artifactId>
            <version>2.0.0-alpha1</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>jul-to-slf4j</artifactId>
            <version>1.7.30</version>
        </dependency>

        <!-- Spring 进行 JSON 数据转换依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
            <version>2.12.1</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.12.1</version>
        </dependency>

        <!-- JSTL 标签库 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>

        <!-- junit 测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- 引入 Servlet 容器中相关依赖 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency>

        <!-- JSP 页面使用的依赖 -->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.2</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.8.6</version>
        </dependency>

        <!-- SpringSecurity 对 web 应用进行权限管理 -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-web</artifactId>
            <version>${mao.spring.security.version}</version>
        </dependency>
        <!-- SpringSecurity 配置 -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
            <version>${mao.spring.security.version}</version>
        </dependency>
        <!-- SpringSecurity 标签库 -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-taglibs</artifactId>
            <version>${mao.spring.security.version}</version>
        </dependency>

    </dependencies>
    <!-- 静态资源过滤 -->
    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
```



## 四、Spring整合MyBatis

![image-20210710230002931](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210710230006.png) 

### 操作清单

- 在子工程中加入搭建环境所需要的具体依赖 
- 准备 jdbc.properties 
- 创建 Spring 配置文件专门配置 Spring 和 MyBatis 整合相关 
- 在 Spring 的配置文件中加载 jdbc.properties 属性文件 
- 配置数据源 
- 测试从数据源中获取数据库连接 
- 配置 SqlSessionFactoryBean 
  - 装配数据源 
  - 指定 XxxMapper.xml 配置文件的位置 
  - 指定 MyBatis 全局配置文件的位置（可选） 
  - 配置 MapperScannerConfigurer 
  - 测试是否可以装配 XxxMapper 接口并通过这个接口操作数据库

 ![image-20210710230931424](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210710230934.png)

### 	1、配置Maven依赖

在 **component模块** 的 pom.xml 配置一些必要的依赖

```xml
    <dependencies>
        <!--项目之间的依赖关系-->
        <dependency>
            <groupId>com.mao</groupId>
            <artifactId>crowdfunding04-admin-entity</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.mao</groupId>
            <artifactId>crowdfunding05-common-util</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <!--mybatis 依赖-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
        </dependency>

        <!-- 导入整合 Spring-MyBatis 的依赖 -->
        <!-- Spring 依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-orm</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
        </dependency>
        <!-- Spring AOP -->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
        </dependency>
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
        </dependency>
        <!-- 数据库依赖 -->
        <!-- MySQL -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!-- 数据源 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <!-- MyBatis -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
        </dependency>
        <!-- MyBatis 与 Spring 整合 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
        </dependency>
        <!-- MyBatis 分页插件 -->
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
        </dependency>
        <!-- Spring 进行 JSON 数据转换依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <!-- JSTL 标签库 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
        </dependency>

        <!-- junit 测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
        </dependency>
    </dependencies>
```

​		**webui模块**配置依赖于component，并引入一些scope为test的依赖（如junit）

```xml
<dependencies>
    <dependency>
        <groupId>org.example</groupId>
        <artifactId>crowdfunding03-admin-component</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
    </dependency>
</dependencies>
```

​	2、创建各配置文件

​		①resources/mybatis/**mybatis-config.xml**（Mybatis配置文件，可以省略）

```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0/EN"
            "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <configuration>
        <!--Spring与MyBatis整合后，MyBatis的配置文件可有可不有-->
    </configuration>
```

​		②resources/**spring-persist-mybatis.xml**（Spring配置文件，用于整合MyBatis）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 加载外部属性文件 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>

    <!-- 配置数据源 -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="username" value="${jdbc.user}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="driverClassName" value="${jdbc.driver}"/>
    </bean>

</beans>
```

​		③resources/**jdbc.properties**（存放数据库连接信息）

```properties
jdbc.user=root
jdbc.password=root
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/project_crowd?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
```

### 2、测试整合是否成功

```java
/**
 * RunWith与ContextConfiguration指定xml的作用与
 * ApplicationContext context = new ClassPathXmlApplicationContext("spring-persist-mybatis.xml");类似
 * 前者通过让测试在Spring容器环境下执行，使得DataSource可以被自动注入，后者导入Spring配置文件
 */
// 在类上标记必要的注解，Spring 整合 Junit
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:spring-persist-mybatis.xml"})
public class CrowdTest {

    @Autowired
    private DataSource dataSource;
    @Test
    public void testConnection() throws SQLException {
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
    }
}
```

可以打印出connection的数据，而不是报空指针异常，得出结论：整合成功。

## 五、配置日志系统

**使用日志的原因：**

​	在实际开发中，如果在所有想查看的地方都通过System.out来打印，会给项目上线带来很多问题
​	System.out本质是一个IO操作，通常IO操作比较消耗性能。如果项目中过多的System.out，则可能对性能造成影响，而如果使用日志系统，就可以通过控制日志级别，来**批量控制打印信息**。



这里使用**slf4j+logback**代替Spring默认使用的commons-loggin日志包。

### 	1、在component中增加依赖

```xml
<!-- 日志 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
</dependency>
<!-- 其他日志框架的中间转换包 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jcl-over-slf4j</artifactId>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jul-to-slf4j</artifactId>
</dependency>
```

### logback.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<configuration debug="true">
    <!-- 控制日志输出的位置 -->
    <appender name="STDOUT"
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 日志输出的格式 -->
            <!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行-->
            <pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n</pattern>
        </encoder>
    </appender>

    <!-- 设置全局日志级别，日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR -->
    <!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志 -->
    <root level="INFO">
        <!-- 指定打印日志的 appender ，这里通过 ”STDOUT“ 引用了前面配置的 appender -->
        <appender-ref ref="STDOUT" />
    </root>

    <!-- 根据特殊需求指定局部日志级别 -->
    <logger name="com.mao.crowd.mapper" level="DEBUG"></logger>

</configuration>
```



### 	2、使用日志打印的方法

```java
@Test
public void test03(){
    //获取Logger对象，这里传入的Class就是当前打印日志的类
    Logger logger = LoggerFactory.getLogger(TestConnection.class);
    //等级 DEBUG < INFO < WARN < ERROR
    logger.debug("I am DEBUG!!!");

    logger.info("I am INFO!!!");

    logger.warn("I am WARN!!!");

    logger.error("I am ERROR!!!");

}
```



## 六、配置声明式事务

​	配置声明式事务的**目的**：希望指定的事务方法中，如果存在多个数据库操作，则要么一起提交，要么一起回滚（rollback），即：事务方法中多个数据库操作，只要有一个失败，则所有操作回滚。

### 1、声明式事务所依赖的包

（前面已经加入了Maven依赖，不需要多次操作了）

```xml
<!-- Spring AOP -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>

<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
</dependency>
```

### 2、配置针对事务的Spring配置文件

![image-20210711113045073](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711113052.png)

**spring-persist-tx.xml**

​	事务方法一般定义在 service 层，**service 层** 放在 component 模块中

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- 配置自动扫描的包：主要是为了把 Service 扫描到 IOC 容器中 -->
    <context:component-scan base-package="com.mao.crowd.service"/>

    <!-- 配置事务管理器 -->
    <bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 装配数据源 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    
    <!-- 配置事务切面 -->
    <aop:config>
        <!-- 考虑到后面整合 SpringSecurity ，避免把 UserDetailsService 加入事务控制，把切入点表达式直接定位到 service 实现类上 -->
        <aop:pointcut id="txPointCut" expression="execution(* *..*ServiceImpl.*(..))"/>

        <!-- 将切入点表达式和事务通知关联起来 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/>
    </aop:config>
    <!-- 配置事务通知 -->
    <tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager">
        <!-- 配置事务特性 -->
        <tx:attributes>
            <!-- 查询方法：配置只读属性，只让数据库知道这是一个查询操作，能够进行一定优化 -->
            <tx:method name="get*" read-only="true"/>
            <tx:method name="query*" read-only="true"/>
            <tx:method name="find*" read-only="true"/>
            <tx:method name="count*" read-only="true"/>

            <!-- 增删改方法：配置事务传播行为、回滚异常 -->
            <!--
                propagation 属性：
                    REQUIRED：默认值，表示当前方法必须工作在事务中，如果当前线程没有开启事务就自己开启事务，如果已经有了事务，就使用已有的事务
                        顾虑：用别人的事务有可能被回滚
                    REQUIRES_NEW：建议使用的值，表示当前方法必须工作在事务中，如果当前线程没有开启事务就自己开启事务，就算已经有了事务，也自己开启新事务
                        好处：不会受到其他事务回滚的影响
            -->
            <!--
                rollback-for 属性：配置事务方法针对什么样的异常进行回滚
                    默认：运行时异常
                    建议：编译时异常和运行时异常都回滚
            -->
            <tx:method name="save*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="update*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="remove*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="batch*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
        </tx:attributes>

    </tx:advice>
</beans>
```

​	配置完成后，在org.fall.service包下，进行数据库操作时，触发异常，即发生回滚，不会依然执行



## 七、表述层环境搭建

**目标：** 1、handler 中装配 Service

​			2、页面能够访问到 handler

`页面-->handler(@RequestMapping)-->Service-->Mapper-->数据库`

![image-20210711114549563](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711114551.png)

​	

首先需要确定已经导入了SpringMVC的依赖，这个在 webui 的依赖工程 component 模块中已经引入，所以在这个模块不用引入

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
</dependency>
```

### 	1、配置web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--配置ContextLoaderListener，加载Spring配置文件-->
    <!--contextConfigLocation需要的内容-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-persist-*.xml</param-value>
    </context-param>
    <!--将ContextLoaderListener加入容器-->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!--配置CharacterEncodingFilter，解决乱码问题-->
    <!--如果web.xml中存在多个Filter，则此Filter必须作为过滤器链的第一个Filter-->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <!-- 指定字符集编码 -->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <!--强制请求进行编码-->
        <init-param>
            <param-name>forceRequestEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
        <!--强制响应进行编码-->
        <init-param>
            <param-name>forceResponseEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <!--设置过滤器过滤的请求的路径（/*表示全部请求）-->
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!--配置DispatcherServlet（即配置SpringMVC的前端控制器）-->
    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--指定SpringMVC配置文件-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-web-mvc.xml</param-value>
        </init-param>

        <!--使DispatcherServlet在Web应用启动时就创建对象并初始化-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
        <!--根据请求的扩展名决定是否交给SpringMVC来处理-->
        <!--
			请求的扩展名应与预计的响应体格式相同
			要求json数据则后缀.json;	要求页面则后缀.html
		-->
        <url-pattern>*.html</url-pattern>
        <url-pattern>*.json</url-pattern>
    </servlet-mapping>
</web-app>
```

### 	2、配置SpringMVC配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 配置自动扫描的包：扫描 handler -->
    <context:component-scan base-package="com.mao.crowd.mvc" />

    <!-- 配置 SpringMVC 的注解驱动 -->
    <mvc:annotation-driven />

    <!-- 配置视图解析器 -->
    <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

</beans>
```

### 	3、测试SSM整合是否成功

​	**Controller控制器代码：**

```java
@Controller
public class TestController {

    @Autowired
    private AdminService adminService;

    @RequestMapping("/test/ssm.html")
    public String testSsm(Model model){
        List<Admin> adminList = adminService.getAll();
        model.addAttribute("adminList",adminList);
        return "target";
    }
}
```

​	**前端代码：**index.jsp

```html
<%-- 一、无base标签：--%>
    <a href="${pageContext.request.contextPath}/test/ssm.html">测试页面</a>

<%-- 二、有base标签：--%>
<head>
    <base href="http://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/">
</head>
<body>
    <a href="test/ssm.html">测试页面</a>
</body>
```

​	**Base标签的要求：**	

​		base 标签必须写在 head 标签内部
  	  base 标签必须在所有“带具体路径”的标签的前面
​	    serverName 部分 EL 表达式和 serverPort 部分 EL 表达式之间必须写“:”
  	  serverPort 部分 EL 表达式和 contextPath 部分 EL 表达式之间绝对不能写“/”
​    	原因：contextPath 部分 EL 表达式本身就是“/”开头，如果多写一个“/”会干扰 Cookie 的工作机制
 	   serverPort 部分 EL 表达式后面必须写“/”



## 八、SpringMVC环境下的Ajax请求

![image-20210711150327426](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711150330.png)

​	检查依赖的包：

```xml
<!-- Spring 进行 JSON 数据转换依赖 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

​	加入jQuery：

![image-20210711150845721](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711150849.png) 

​	测试Ajax（基于jQuery）：

​		jQuery代码：

```javascript
    <script>
      $(function (){
        $("#btn1").click(function (){
          // ajax 请求
          $.ajax({
            url: "send/array/one.html",        // 请求目标资源的地址
            type: "post",                  // 请求方式
            data: {
              array: [5,8,12]
            },                // 要发送的请求参数
            dataType: "text",              // 如何对待服务器端返回的数据
            success: function (response) {     // 服务器端成功处理请求后调用的回调函数，response 是响应体
              alert(response);
            },
            error: function (response) {      // 服务器端处理请求失败后调用的回调函数，response 是响应体
              alert(response);
            }
          });
        });
        $("#btn2").click(function (){
            // ajax 请求
            $.ajax({
                url: "send/array/two.html",        // 请求目标资源的地址
                type: "post",                  // 请求方式
                data: {
                    "array[0]": 5,
                    "array[1]": 8,
                    "array[2]": 12
                },                // 要发送的请求参数
                dataType: "text",              // 如何对待服务器端返回的数据
                success: function (response) {     // 服务器端成功处理请求后调用的回调函数，response 是响应体
                    alert(response);
                },
                error: function (response) {      // 服务器端处理请求失败后调用的回调函数，response 是响应体
                    alert(response);
                }
            });
        });
        $("#btn3").click(function (){

              // 准备好要发送到服务器端的数组
              let array = [5,8,12];
              console.log(array.length);
              // 将 JSON 数组转换为 JSON 字符串
              let requestBody = JSON.stringify(array);
              console.log(requestBody.length);

              // ajax 请求
              $.ajax({
                  url: "send/array/three.html",        // 请求目标资源的地址
                  type: "post",                  // 请求方式
                  data: requestBody,                // 要发送的请求参数
                  contentType: "application/json;charset=UTF-8",  // 设置请求体的内容类型
                  dataType: "text",              // 如何对待服务器端返回的数据
                  success: function (response) {     // 服务器端成功处理请求后调用的回调函数，response 是响应体
                      alert(response);
                  },
                  error: function (response) {      // 服务器端处理请求失败后调用的回调函数，response 是响应体
                      alert(response);
                  }
              });
          });
        $("#btn4").click(function () {
           // 准备发送的数据
           let student = {
               stuId: 5,
               stuName: "tom",
               address: {
                   province: "广东",
                   city: "深圳",
                   street: "后瑞"
               },
               subjectList: [
                   {
                       subjectName: "JavaSE",
                       subjectScore: 100
                   },{
                       subjectName: "SSM",
                       subjectScore: 99
                   }
               ],
               map: {
                   k1: "v1",
                   k2: "v2"
               }
           }
           // 将 JSON 对象转换为 JSON 字符串
           let requestBody = JSON.stringify(student);

           // 发送 Ajax 请求
           $.ajax({
               url: "send/compose/object.json",
               type: "post",
               data: requestBody,
               contentType: "application/json;charset=UTF-8",
               dataType: "json",
               success: function (response) {
                   console.log(response);
               },
               error: function (response) {
                   console.log(response);
               }
           })
       });
      })
    </script>
```

​		对应的四个按钮：

```html
      <a href="test/ssm.html">测试 ssm 整合环境</a>

      <br />
      <br />

      <button id="btn1">Send [5,8,12] One</button>

      <br />
      <br />

      <button id="btn2">Send [5,8,12] Two</button>

      <br />
      <br />

      <button id="btn3">Send [5,8,12] Three</button>

      <br />
      <br />

      <button id="btn4">Send Compose Object</button>
```

​		对应的控制层的四个方法：

```java
@Controller
public class TestController {

    @Autowired
    private AdminService adminService;
    private Logger logger = LoggerFactory.getLogger(TestController.class);

    @RequestMapping("/test/ssm.html")
    public String testSsm(Model model){
        List<Admin> adminList = adminService.getAll();
        model.addAttribute("adminList",adminList);
        return "target";
    }

    @ResponseBody
    @RequestMapping("/send/array/one.html")
    public String testReceiverArrayOne(@RequestParam("array[]") List<Integer> array){
        for (Integer number : array) {
            System.out.println("number = " + number);
        }
        return "success";
    }

    @ResponseBody
    @RequestMapping("/send/array/two.html")
    public String testReceiverArrayTwo(ParamData paramData){
        List<Integer> array = paramData.getArray();
        for (Integer number : array) {
            System.out.println("number = " + number);
        }
        return "success";
    }

    @ResponseBody
    @RequestMapping("/send/array/three.html")
    public String testReceiverArrayThree(@RequestBody List<Integer> array){

        for (Integer number : array) {
            logger.info("number = " + number);
        }
        return "success";
    }


    @ResponseBody
    @RequestMapping("/send/compose/object.json")
    public ResultEntity<Student> testReceiveComposeObject(@RequestBody Student student) {
        logger.info(student.toString());

        // 将“查询”到的 Student 对象封装到 ResultEntity 中返回
        return ResultEntity.successWithData(student);
    }
}
```

==如果希望通过@RequestBody接收前端发来的JSON数据，则前端发来的数据需要进行以下几步：==

1. 准备好要发送的数据（需要是JSON对象或JSON数组）
2. 通过JSON.stringify()方法，转换成JSON字符串
3. 将JSON字符串直接赋值给data属性
4. 必须设置**contentType: "application/json;charset=UTF-8"**

此时后端在加入了json依赖，并开启mvc注解驱动，就可以使用RequestBody接收JSON数据。

==注意，如果后端返回给前端的数据是 json，而且前端接受形式也是 json 的话，请求的路径应该改成 *.json，否则会出现 406==



### 统一后端返回数据格式

通过工具类，实现统一后端返回的数据格式

​	工具类代码：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ResultEntity<T> {

    public static final String SUCCESS = "SUCCESS";
    public static final String FAILED = "FAILED";


    // 用来封装当前请求处理的结果是成功还是失败
    private String result;

    // 请求处理失败时返回的错误消息
    private String message;

    // 要返回的数据
    private T data;

    /**
     * 请求处理成功且不需要返回数据时使用的工具方法，一般用于增删改
     * @param <Type> 第一个<Type>表示声明一个泛型Type，第二个和return中的<Type>表示使用该泛型
     * @return
     */
    public static <Type> ResultEntity<Type> successWithoutData() {
        return new ResultEntity<Type>(SUCCESS,null,null);
    }

    /**
     * 请求处理成功需要返回数据时使用的工具方法，一般用于查询
     * @param data  要返回的数据
     * @param <Type>
     * @return
     */
    public static <Type> ResultEntity<Type> successWithData(Type data) {
        return new ResultEntity<>(SUCCESS,null,data);
    }

    /**
     * 请求处理失败后使用的工具方法
     * @param message  失败的错误信息
     * @param <Type>
     * @return
     */
    public static <Type> ResultEntity<Type> failed(String message) {
        return new ResultEntity<Type>(FAILED,null,null);
    }
}
```

​	工具类中静态方法的泛型Type，代表了在前端请求后，后端返回的数据的类型；只是因为静态方法中不能调用非静态的属性，因此需要重新声明一个泛型，名	字为Type（其他也可以）。

​		即想要返回一个Student对象时，就通过方法

```java
@RequestMapping(...)
@ResponseBody
public ResultEntity<Student> getStudent(){
    //...例如进行数据库查询操作等
    return ResultEntity.successWithData(student);
}
```



## 九、异常处理

![image-20210711170448282](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711170450.png) 

**目标**：统一管理项目中的异常。

- 抛出异常
- 返回给前端异常信息
  - 普通请求：在返回的页面上显示异常信息
  - Ajax请求：返回JSON格式的数据

观察浏览器的开发者工具中，发现可以根据客户端发送的请求类型，区别是普通请求还是Ajax请求。

![image-20210711172023062](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711172025.png) 

根据这一特点，编写一个工具类，其中一个静态方法用来判断请求是否是JSON请求

```java
/**
 * Author: Administrator
 * Date: 2021/7/11 17:15
 * Description: 判断请求类型的工具类
 */
public class CrowdUtil {

    /**
     * 判断当前请求是否为 Ajax 请求
     * @param request 请求对象
     * @return
     *      true：当前请求是 Ajax 请求
     *      false：当前请求不是 Ajax 请求
     */
    public static boolean judgeRequestType(HttpServletRequest request) {

        // 1、获取请求消息头
        String acceptHeader = request.getHeader("Accept");
        String xRequestHeader = request.getHeader("X-Requested-With");

        // 2、判断
        return (acceptHeader != null && acceptHeader.equals("application/json")) ||
                (xRequestHeader != null && xRequestHeader.equals("XMLHttpRequest"));
    }
}
```

### 异常映射实现的方式

#### 	一、通过XML配置实现

在mvc的配置文件中将SimpleMappingExceptionResolver加入容器，在exceptionMappings中配置异常与错误页面的映射

但是此时并未实现区别JSON请求与普通请求的要求。在 `spring-web-mvc.xml` 中配置

```xml
    <!-- 配置基于 XML 的异常映射 -->
    <bean id="simpleMappingExceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <!-- key 属性指定异常全类名 -->
                <!-- 标签体中写对应的视图（这个值要拼前后缀得到具体的路径） -->
                <prop key="java.lang.Exception">system-error</prop>
            </props>
        </property>
    </bean>
```

#### 	二、通过注解实现



这里通过使用前面编写的工具类的判断方法，实现对不同请求类型进行不同处理。

```java
/**
 * Author: Administrator
 * Date: 2021/7/11 17:35
 * Description: 异常映射处理
 */

/**
 * @ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,
 * 可对controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理
 */
@ControllerAdvice
public class CrowdExceptionResolver {


    @ExceptionHandler(value = NullPointerException.class)
    public ModelAndView resolverNullPointException(

            // 实际捕获的异常类型
            NullPointerException exception,
            // 当前请求对象
            HttpServletRequest request,
            // 当前响应对象
            HttpServletResponse response
    ) throws IOException {
        // 发生异常后需要返回的视图
        String viewName = "system-error";
        return commonResolver(viewName,exception,request,response);
    }


    /**
     * 将异常处理整合成方法提高代码复用
     * @return
     */
    private ModelAndView commonResolver(
            // 出现异常后需要跳转的视图
            String viewName,
            // 实际捕获的异常类型
            NullPointerException exception,
            // 当前请求对象
            HttpServletRequest request,
            // 当前响应对象
            HttpServletResponse response
    ) throws IOException {
        // 1、判断当前请求类型
        boolean judgeResult = CrowdUtil.judgeRequestType(request);
        // 2、如果是 Ajax 请求
        if(judgeResult) {
            // 3、创建 ResultEntity 对象
            ResultEntity<Object> resultEntity = ResultEntity.failed(exception.getMessage());
            // 4、创建 Gson 对象
            Gson gson = new Gson();
            // 5、将 ResultEntity 对象转换为 JSON 字符串
            String json = gson.toJson(resultEntity);
            // 6、将 JSON 字符串作为响应体返回给浏览器
            response.getWriter().write(json);
            // 7、由于上面已经通过原生的 response 对象返回了响应，所以不提供 ModelAndView
            return null;
        }
        // 8、如果不是 Ajax 请求则创建 ModelAndView 对象
        ModelAndView mv = new ModelAndView();
        // 9、将 Exception 对象存入模型
        mv.addObject(CrowdConstant.ATTR_NAME_EXCEPTION,exception);
        // 10、设置对应的视图名称
        mv.setViewName(viewName);
        // 11、返回视图 ModelAndView 对象
        return mv;
    }
}
```



## 十、以常量管理常用的属性

对于经常使用到且存在复用的属性名，可以单独设置一个常量类。这样的好处是可以减少因拼写导致的错误。

```java
/**
 * Author: Administrator
 * Date: 2021/7/11 18:08
 * Description: 存储常量
 */
public class CrowdConstant {


    /*************************账户相关**********************8*/
    public static final String MESSAGE_LOGIN_FAILED = "抱歉！账号密码错误！请重新输入！";
    public static final String MESSAGE_LOGIN_ACCT_ALREADY_IN_USE = "抱歉！这个账号已经被使用了！";
    public static final String MESSAGE_ACCESS_FORBIDDEN = "请登录后再访问！";


    // 异常
    public static final String ATTR_NAME_EXCEPTION = "exception";
}
```



## 十一、前端页面引入

### 	引入登录页面

1、引入需要的静态资源

![静态资源](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711183851.png) 



2、将登录页面的代码复制入创建的**admin-login.jsp**文件，并进行适当的修改（还未完全修改）

​	主要是修改了编码方式为统一的UTF-8；添加了base标签；提前设置form表单的action和method；设置了账号密码的name属性。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keys" content="">
    <meta name="author" content="">
    <base href="http://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/">
    <link rel="stylesheet" href="bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="css/font-awesome.min.css">
    <link rel="stylesheet" href="css/login.css">
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <div><a class="navbar-brand" href="index.html" style="font-size:32px;">尚筹网-创意产品众筹平台</a></div>
        </div>
    </div>
</nav>

<div class="container">

    <form action="admin/login/login.html" method="post" class="form-signin" role="form">
        <h2 class="form-signin-heading"><i class="glyphicon glyphicon-log-in"></i> 用户登录</h2>
        <div class="form-group has-success has-feedback">
            <input type="text" name="login-user" class="form-control" id="inputSuccess4" placeholder="请输入登录账号" autofocus>
            <span class="glyphicon glyphicon-user form-control-feedback"></span>
        </div>
        <div class="form-group has-success has-feedback">
            <input type="text" name="login-pwd" class="form-control" id="inputSuccess4" placeholder="请输入登录密码" style="margin-top:10px;">
            <span class="glyphicon glyphicon-lock form-control-feedback"></span>
        </div>
        <div class="checkbox" style="text-align:right;"><a href="reg.html">我要注册</a></div>
        <button type="submit" class="btn btn-lg btn-success btn-block">登录</button>
    </form>
</div>
<script src="jquery/jquery-2.1.1.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
```

------

#### 遇到的奇怪的问题

在mvc配置文件中通过view-controller，使通过path指定的路径，访问登录页面（因为只需要单纯的访问而不需要附带数据等操作，因此使用此方法相比handler方法转发更加方便）

```xml
<!--通过view-controller 来设置一些直接的页面跳转-->
<mvc:view-controller path="/admin/login/page.html" view-name="admin-login"/>
```

​	==但是最后测试下来，发现访问时会**发生404错误**：==

​	我使用的默认是Edge Beta浏览器，当使用Edge浏览器时，可以通过链接访问登录页面，也可以直接使用` localhost:8888/admin/login/page.html`访问登录页面；但是当使用了chrome浏览器，使用地址栏输入...page.html时，发生奇怪的事情：报404错误，且之后edge也不能访问登录页面。最后尝试了很久，觉得应该是Tomcat缓存的问题，但尝试了多种清理缓存的方法，还是没有效果，最后**去掉了IDEA中对tomcat的一个勾选**：

![](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711183854.png)

这样可以算是“暂时”解决了问题。

------

### 尝试使用layer弹层组件

​	1、网上下载layer.js（此处是3.3.1版本）

​	2、引入与测试使用layer组件

​	注意：layer组件依赖于jquery，因此layer的引入必须在jquery之后，否则会出错。

```html
<script src="jquery/jquery-3.4.1.js" type="text/javascript"></script>
<script src="layer/layer.js" type="text/javascript"></script>
<script>
    $("#btn5").click(function () {
        layer.msg("test layer");
    });
</script>
<body>
 	<button id="btn5">Test layer</button>
</body>
```



### 修饰错误页面

借助登录页面的样式，给错误页面**换壳**

使错误页面可以显示错误信息，并且提供了返回上一层的按钮。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keys" content="">
    <meta name="author" content="">
    <base href="http://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/"/>
    <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/font-awesome.min.css">
    <link rel="stylesheet" href="css/login.css">
    <script src="jquery/jquery-2.1.1.min.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
    <script>
        $(function () {
            $("#goBackBtn").click(function () {
                window.history.back();
            });
        })
    </script>
    <style>

    </style>
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <div><a class="navbar-brand" href="index.html" style="font-size:32px;">尚筹网-创意产品众筹平台</a></div>
        </div>
    </div>
</nav>

<div class="container">

    <h2 class="form-signin-heading" style="text-align: center">
        <i class="glyphicon glyphicon-log-in"></i> 尚筹网系统消息
    </h2>

    <!--
        requestScope 对应的是存放 request 域数据的 Map
        requestScope.exception 相当于 request.getAttribute("exception")
        requestScope.exception.message 相当于 exception.getMessage()
    -->
    <h3 style="text-align: center">请求出现错误：</h3>
    <h3 style="text-align: center">${requestScope.exception}</h3>
    <br/>
    <button id="goBackBtn" class="btn btn-lg btn-success btn-block" style="width: 150px;margin: 50px auto 0px auto ">点我返回上一步</button>

</div>
</body>
</html>
```



最后此阶段完成时的项目目录结构图如下：

![项目结构图](https://gitee.com/lloamhh/spring-img/raw/master/img/Crowdfunding/20210711201331.png) 